<html>
<style>
    html {
        background: radial-gradient(#010101, #070709);
    }
    @font-face {
        font-family: 'BOUNDED';
        src: url("Bounded-Regular.ttf");
    }
    .vl_text {
        color: #fff;
        font-family: 'BOUNDED';
        text-transform: capitalize;
        font-weight: 500;
        font-style: italic;
        margin: 60px;
    }
    #in0, #in2, #fullHex {
        color: #fff;
        font-family: 'BOUNDED';
        font-style: italic;
        margin: 60px;
        background: #070709;
        border: 1px solid #fff;
        width: 500px;
        height: 100px;
        resize: none;
        outline: none;
    }
    .vl_text2 {
        color: #fff;
        font-family: 'BOUNDED';
        text-transform: capitalize;
        font-weight: 500;
        font-style: italic;
        margin-left: 60px;
        margin-top: 0px;
        margin-bottom: -40px;
    }
    .gen {
        color: #fff;
        font-family: 'BOUNDED';
        text-transform: capitalize;
        font-weight: 500;
        font-style: italic;
        display: inline-block;
        margin-left: 60px;
        margin-top: -60px;
        margin-bottom: 10px;
        background: #070709;
        border: 1px solid #fff;
        width: 500px;
        height: 50px;
    }
    .gen:hover {
        background: #353555;
    }
    .dmode {
        color: #fff;
        font-family: 'BOUNDED';
        text-transform: capitalize;
        font-weight: 500;
        font-style: italic;
        margin-top: -50px;
        margin-bottom: -40px;
        background: #070709;
        border: 1px solid #fff;
        width: 50px;
        height: 50px;
    }
    .dmode:hover {
        background: #353555;
    }
    .derr {
        color: #ff0069;
        font-family: 'BOUNDED';
        font-weight: 500;
        font-style: italic;
        margin-left: 60px;
        margin-top: 0px;
        margin-bottom: -40px;
    }
    .derr2 {
        color: #1234f5;
        font-family: 'BOUNDED';
        font-weight: 500;
        font-style: italic;
        margin-left: 60px;
        margin-top: 0px;
        margin-bottom: -40px;
    }
</style>
<h1 class="vl_text">AES CRYPTOR BY HCPP</h1>
<h1 class="vl_text2" id="_tx">Текст для шифрования</h1>
<textarea id="in0"></textarea>
<br>
<button class="gen">Зашифровать</button>
<button class="dmode">Dec</button>
<br>
<h1 class="vl_text2" id="_tx2">Вывод (64 символа)</h1>
<textarea id="in2"></textarea>
<h1 class="vl_text2">Полный hex для расшифровки</h1>
<textarea id="fullHex"></textarea>
<p class="derr2">GITHUB.COM/HCPP20334</p>
<p class="derr"></p>
<script>
async function generateKey() {
  const hexKey = 'bcecedfa47eb363152239c10a3c8eaf821a768e29ceb2bc130af286e96842fc3';
  const keyData = new Uint8Array(
    hexKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
  );
  return await crypto.subtle.importKey(
    'raw',
    keyData,
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  );
}

async function encryptMessage(message, key) {
  try {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const msgUint8 = new TextEncoder().encode(message);
    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv,
      },
      key,
      msgUint8
    );
    const encryptedArray = new Uint8Array(encrypted);
    // Объединяем IV и зашифрованные данные
    const combined = new Uint8Array(iv.length + encryptedArray.length);
    combined.set(iv);
    combined.set(encryptedArray, iv.length);
    // Кодируем в hex
    const fullHex = Array.from(combined)
      .map(b => b.toString(16).padStart(2, "0"))
      .join("");
    // Ограничиваем до 64 символов для отображения
    const output = fullHex.slice(0, 64).padEnd(64, "0");
    return { output, fullHex };
  } catch (e) {
    throw new Error("Ошибка шифрования: " + e.message);
  }
}

async function decryptMessage(hexInput, key) {
  try {
    // Декодируем hex
    const combined = new Uint8Array(
      hexInput.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
    );
    // Извлекаем IV (12 байт) и зашифрованные данные
    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);
    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: iv,
      },
      key,
      encrypted
    );
    return new TextDecoder().decode(decrypted);
  } catch (e) {
    throw new Error("Ошибка расшифровки: неверный формат или данные");
  }
}

const AES = {
  async enc(message, key) {
    return await encryptMessage(message, key);
  },
  async dec(hexInput, key) {
    return await decryptMessage(hexInput, key);
  }
};

(async () => {
  const str = ["Текст для шифрования", "Текст для расшифровки"];
  const strb = ["Зашифровать", "Расшифровать"];
  let _dmode = 1; // 1 - шифрование, 0 - расшифровка
  const _derror = document.querySelector(".derr");
  const key = await generateKey();

  function api_log(D) {
    _derror.innerHTML = D;
  }

  window.addEventListener("error", function(api_error) {
    api_log(api_error.error + " line: " + api_error.lineno);
  });

  const CRYPTOR = {
    text: {
      t0: document.querySelector("#_tx"),
      t1: document.querySelector("#_tx2"),
      tex0: document.querySelector("#in0"),
      tex1: document.querySelector("#in2"),
      fullHex: document.querySelector("#fullHex"),
    },
    button: {
      gen: document.querySelector(".gen"),
      mode: document.querySelector(".dmode"),
    },
    hash: {
      async enc(input) {
        const result = await AES.enc(input, key);
        return result;
      },
      async dec(input) {
        return await AES.dec(input, key);
      }
    }
  };

  let _hash_0x3f3q = "";

  CRYPTOR.text.tex0.oninput = function() {
    _hash_0x3f3q = this.value;
  };

  CRYPTOR.button.mode.onclick = function() {
    _dmode = !_dmode;
    CRYPTOR.button.mode.innerHTML = _dmode ? "Dec" : "Enc";
    CRYPTOR.button.gen.innerHTML = _dmode ? strb[0] : strb[1];
    CRYPTOR.text.t0.innerHTML = _dmode ? str[0] : str[1];
    CRYPTOR.text.t1.innerHTML = _dmode ? "Зашифрованный текст (64 символа)" : "Расшифрованный текст";
    CRYPTOR.text.tex1.value = "";
    CRYPTOR.text.fullHex.value = "";
    api_log("");
  };

  CRYPTOR.button.gen.onclick = async function() {
    try {
      if (!_hash_0x3f3q) {
        api_log("Введите текст для обработки");
        return;
      }
      if (_dmode) {
        // Режим шифрования
        const result = await CRYPTOR.hash.enc(_hash_0x3f3q);
        CRYPTOR.text.tex1.value = result.output;
        CRYPTOR.text.fullHex.value = result.fullHex;
        if (result.fullHex.length > 64) {
          api_log("Для расшифровки используйте полный hex из поля ниже");
        } else {
          api_log("");
        }
      } else {
        // Режим расшифровки
        const result = await CRYPTOR.hash.dec(_hash_0x3f3q);
        CRYPTOR.text.tex1.value = result;
        CRYPTOR.text.fullHex.value = "";
        api_log("");
      }
    } catch (e) {
      api_log(e.message);
    }
  };
})();
</script>
</html>